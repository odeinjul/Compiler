# Part 1
## Problem 1-1
如果在命令行下执行 gcc -DNEG -E sample.c -o sample.i 生成的sample.i 与之前的有何区别？

## Answer 1-1
区别：由于 ```-D name``` 会预定名为 name 的宏，所以 ```-DNEG``` 实际上预定义了 ```NEG``` 这个宏（空格可被省略，等效于```-DNEG```）。预处理时这里依照条件编译选择了 ```M``` 定义为-4而不是之前的4。

## Problem 1-2
请对比 sample-32.s 和 sample.s，找出它们的区别，并上网检索给出产生这些区别的原因。如：
pushq和pushl
rsp和esp

## Answer 1-2
### 寄存器使用 pushl & popl：
32位中使用 ```pushl``` 和 ```popl``` 操作来压栈和弹栈，以及使用 ```movl``` 来操作32位数据。

64位中则使用 ```pushq``` 和 ```popq``` 操作，使用 ```movq``` 来操作64位数据。

后缀l和q分别代表```long``` 和 ```quad```，即不同的数据大小。```long``` 表示32位数据，即单字，通常为4字节，```quad``` 表示64位数据，即双字，通常为8字节。

### 寄存器名称 rsq & esp：
32位中使用 ```%ebp``` 和 ```%esp```，这是32位架构中的寄存器。
64位中使用 ```%rbp``` 和 ```%rsp```，这是64位的寄存器。

### 栈帧操作：
32位中，```.cfi_def_cfa_offse``` 和 ```.cfi_offset``` 操作的单位是4字节。
64位中，```.cfi_def_cfa_offset``` 和 ```.cfi_offset``` 操作的单位是8字节。
因此 ```offset``` 的数字不同。

## Problem 1-3 
你可以用 clang 替换 gcc，重复上面的各步，比较使用 clang 和 gcc 分别输出的结果有何异同。

## Answer 1-3
### 预处理
基本相同，最上部生成的用于指示源文件中的位置信息以及一些编译器内部的信息不同。

### 汇编得到汇编文件
某些flag名不同，clang汇编得到的汇编语言偏长，且更复杂，用的寄存器更多。

### 翻译成机器语言
这一步的差异主要取决于汇编文件（上一步）的差异。
clang和gcc这一步本身的行为差异很小。

### 生成可执行文件
输出、行为相同，clang生成的可执行文件消耗内存偏多。